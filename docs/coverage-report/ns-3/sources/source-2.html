


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Play</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.heshus.game.engine</a>
</div>

<h1>Coverage Summary for Class: Play (com.heshus.game.engine)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Play</td>
<td class="coverageStat">
  <span class="percent">
    7.1%
  </span>
  <span class="absValue">
    (1/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.2%
  </span>
  <span class="absValue">
    (2/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.5%
  </span>
  <span class="absValue">
    (4/263)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Play$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Play$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Play$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Play$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    4.5%
  </span>
  <span class="absValue">
    (1/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3%
  </span>
  <span class="absValue">
    (2/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (4/281)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.heshus.game.engine;
&nbsp;
&nbsp;import com.badlogic.gdx.*;
&nbsp;import com.badlogic.gdx.audio.Music;
&nbsp;import com.badlogic.gdx.graphics.Color;
&nbsp;import com.badlogic.gdx.graphics.OrthographicCamera;
&nbsp;import com.badlogic.gdx.graphics.Texture;
&nbsp;import com.badlogic.gdx.graphics.g2d.*;
&nbsp;import com.badlogic.gdx.maps.tiled.TiledMap;
&nbsp;import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
&nbsp;import com.badlogic.gdx.maps.tiled.TmxMapLoader;
&nbsp;import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
&nbsp;import com.badlogic.gdx.math.Vector2;
&nbsp;import com.badlogic.gdx.scenes.scene2d.InputEvent;
&nbsp;import com.badlogic.gdx.scenes.scene2d.Stage;
&nbsp;import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
&nbsp;import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
&nbsp;import com.badlogic.gdx.utils.ScreenUtils;
&nbsp;import com.badlogic.gdx.utils.viewport.ExtendViewport;
&nbsp;import com.heshus.game.entities.Player;
&nbsp;import com.heshus.game.manager.ActivityManager;
&nbsp;import com.badlogic.gdx.graphics.g2d.GlyphLayout;
&nbsp;import com.badlogic.gdx.audio.Sound;
&nbsp;
&nbsp;import com.heshus.game.screens.states.GameOverScreen;
&nbsp;import com.heshus.game.screens.states.PauseMenu;
&nbsp;import com.heshus.game.screens.states.SettingsMenu;
&nbsp;import com.badlogic.gdx.scenes.scene2d.ui.Button;
&nbsp;
&nbsp;/**
&nbsp; * The Play class represents the game screen and manages some of the states functionalities
&nbsp; * as well as handling user input and game sprites
&nbsp; * It&#39;s also responsible for drawing the game world, the player character,
&nbsp; * and the UI elements like the pause and settings menus. It also handles sound effects
&nbsp; * and music playback based on game events.
&nbsp; * creates new instance of the Play screen with specific game and player sprite settings.
&nbsp; */
<b class="nc">&nbsp;public class Play implements Screen {</b>
&nbsp;
&nbsp;    public static final int GAME_RUNNING = 0;
&nbsp;    public static final int GAME_PAUSED = 1;
&nbsp;    public static final int GAME_SETTINGS = 2;
&nbsp;    public static final int GAME_OVER = 3;
&nbsp;    public static final int GAME_MAINMENU = 4;
&nbsp;    public static final int GAME_LEADERBOARD = 5;
&nbsp;    public static final int GAME_PLAYER_NAME = 6;
&nbsp;    public static final int GAME_PLAYER_SELECT = 7;
&nbsp;
&nbsp;    public static int state;
&nbsp;    private final HesHusGame game;
&nbsp;    private TiledMap map;
&nbsp;    private OrthogonalTiledMapRenderer renderer;
&nbsp;    private OrthographicCamera camera;
&nbsp;    private Player player;
&nbsp;    private static BitmapFont font;
&nbsp;    private ActivityManager activityManager;
<b class="nc">&nbsp;    private float volume = 0.5f;</b>
&nbsp;
&nbsp;    private Sprite blankTexture, textBubble, dimTexture;
&nbsp;    private float currentAlpha;
&nbsp;    private Texture TblankTexture, textBubbleTexture;
&nbsp;    private ExtendViewport extendViewport;
&nbsp;
&nbsp;    private PauseMenu pauseMenu;
&nbsp;    private SettingsMenu settingsMenu;
&nbsp;
&nbsp;    private Texture counterBoxTexture;
&nbsp;    private Texture verticalBarTexture;
&nbsp;    private Sprite verticalBarSprite;
&nbsp;
&nbsp;    private float bubbleTimer;
&nbsp;
&nbsp;    // Walking sounds
&nbsp;    private Sound walkingSound1;
&nbsp;    private Sound walkingSound2;
&nbsp;    private Sound walkingSound3;
&nbsp;    private Sound walkingSound4;
<b class="nc">&nbsp;    private int currentWalkingSoundIndex = 0;</b>
<b class="nc">&nbsp;    private boolean isWalking = false;</b>
&nbsp;
<b class="nc">&nbsp;    private float walkingSoundTimer = 0;</b>
&nbsp;
&nbsp;    // 1/4th of a second delay between sounds, because our avatar is running everywhere
<b class="nc">&nbsp;    private final float WALKING_SOUND_DELAY = 0.25f;</b>
&nbsp;    private Music backgroundMusic;
&nbsp;
&nbsp;    private Texture increaseVolumeTexture;
&nbsp;    private Texture lowerVolumeTexture;
&nbsp;    private Texture volumeOffTexture;
&nbsp;    private Texture volumeOnTexture;
&nbsp;    private Stage stage;
&nbsp;
&nbsp;    private Sprite moonSprite;
&nbsp;    private Texture moonTexture;
&nbsp;
&nbsp;    private Sound clickSound;
&nbsp;    private final Texture playerTexture;
&nbsp;    private InputMultiplexer inputMultiplexer;
&nbsp;    private Button increaseVolumeButton;
&nbsp;    private Button lowerVolumeButton;
&nbsp;    private Button volumeOffButton;
&nbsp;    private Button volumeOnButton;
&nbsp;
&nbsp;
&nbsp;    public static final String MAP = &quot;MapRelated/gamemap.tmx&quot;;
&nbsp;    public static final String WHITE_SQUARE = &quot;Icons/WhiteSquare.png&quot;;
&nbsp;    public static final String TEXT_BUBBLE = &quot;Icons/textBubble.png&quot;;
&nbsp;    public static final String COUNTER_BOX = &quot;Icons/counter-box.png&quot;;
&nbsp;    public static final String VERTICAL_BAR = &quot;Icons/vertical-bar.png&quot;;
&nbsp;
&nbsp;    public static final String TILE_1 = &quot;Sounds/tile1.mp3&quot;;
&nbsp;    public static final String TILE_2 = &quot;Sounds/tile2.mp3&quot;;
&nbsp;    public static final String TILE_3 = &quot;Sounds/tile3.mp3&quot;;
&nbsp;    public static final String TILE_4 = &quot;Sounds/tile4.mp3&quot;;
&nbsp;
&nbsp;    public static final String CLICK = &quot;Sounds/switch2.ogg&quot;;
&nbsp;    public static final String VOLUME_UP = &quot;Icons/increase-volume.png&quot;;
&nbsp;    public static final String VOLUME_DOWN = &quot;Icons/lower-volume.png&quot;;
&nbsp;    public static final String VOLUME_OFF = &quot;Icons/volume-off.png&quot;;
&nbsp;    public static final String VOLUME_ON = &quot;Icons/volume-on.png&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Create an instance of the game play screen
&nbsp;     * @param playerSpriteSelection The texture for the player sprite to be used in the game.* Create the Play instance
&nbsp;     * @param game the game instance
&nbsp;     */
<b class="nc">&nbsp;    public Play(HesHusGame game, Texture playerSpriteSelection) {</b>
<b class="nc">&nbsp;        this.game = game;</b>
<b class="nc">&nbsp;        this.playerTexture = playerSpriteSelection;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    /**
&nbsp;     * Renders the game world, player, and UI elements. This method is called every frame.
&nbsp;     *
&nbsp;     * @param delta The time in seconds since the last render call.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void render(float delta) {
<b class="nc">&nbsp;        update();</b>
<b class="nc">&nbsp;        draw(delta);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the game world, including the map, player, and HUD elements.
&nbsp;     */
&nbsp;    private void draw(float delta){
<b class="nc">&nbsp;        ScreenUtils.clear(0,0,0,1);</b>
&nbsp;        //CAMERA
<b class="nc">&nbsp;        int cameraSmoothness = 4; //higher looks smoother! makes it take longer for camera to reach player pos</b>
<b class="nc">&nbsp;        camera.position.set(((player.getX() + player.getWidth() / 2)+(camera.position.x *(cameraSmoothness-1)))/cameraSmoothness, ((player.getY() + player.getHeight() / 2)+(camera.position.y *(cameraSmoothness-1)))/cameraSmoothness, 0);</b>
<b class="nc">&nbsp;        lockCameraInTiledMapLayer(camera,(TiledMapTileLayer) map.getLayers().get(2)); //locks camera position so it cannot show out of bounds</b>
<b class="nc">&nbsp;        camera.position.set(Math.round(camera.position.x) ,Math.round(camera.position.y),0);//This is needed to stop black lines between tiles. I think something to do with the tilemaprenderer and floats causes this</b>
<b class="nc">&nbsp;        camera.viewportWidth = Math.round(camera.viewportWidth);</b>
<b class="nc">&nbsp;        camera.viewportHeight = Math.round(camera.viewportHeight);</b>
<b class="nc">&nbsp;        camera.update();</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        float padding = 10; // Adjust padding as needed</b>
<b class="nc">&nbsp;        float buttonSize = 50; // The size of the buttons, adjust as needed</b>
&nbsp;        // Calculate the positions based on the updated camera position
<b class="nc">&nbsp;        float baseX = camera.position.x + camera.viewportWidth / 2 - buttonSize - padding;</b>
<b class="nc">&nbsp;        float baseY = camera.position.y + camera.viewportHeight / 2 - padding - buttonSize;</b>
&nbsp;
&nbsp;        // Set the position for each volume button to always stay in one place on screen
&nbsp;
<b class="nc">&nbsp;        increaseVolumeButton.setPosition(baseX - 2 * buttonSize, baseY);</b>
<b class="nc">&nbsp;        lowerVolumeButton.setPosition(baseX - 3 * buttonSize, baseY);</b>
<b class="nc">&nbsp;        volumeOffButton.setPosition(baseX - buttonSize, baseY);</b>
<b class="nc">&nbsp;        volumeOnButton.setPosition(baseX, baseY);</b>
&nbsp;
&nbsp;        //Tilemap
<b class="nc">&nbsp;        renderer.setView(camera);</b>
&nbsp;       //takes a layers[] argument if we want to specifically render certain layers
<b class="nc">&nbsp;        renderer.render(); </b>
<b class="nc">&nbsp;        renderer.getBatch().begin();</b>
&nbsp;        //Player
<b class="nc">&nbsp;        player.draw(renderer.getBatch());</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        switch (state) {</b>
&nbsp;            case(GAME_RUNNING):
<b class="nc">&nbsp;                activityManager.checkActivity(</b>
<b class="nc">&nbsp;                        player.getBoundingRectangle(),</b>
<b class="nc">&nbsp;                        Gdx.input.isKeyJustPressed(Input.Keys.E),</b>
<b class="nc">&nbsp;                        player.getX(), player.getY()</b>
&nbsp;                );
&nbsp;                //HUD
&nbsp;                //Drawing energy bar, can be replaced for a standard energy bar with comments
<b class="nc">&nbsp;                renderer.getBatch().setColor(Color.GRAY);</b>
&nbsp;
<b class="nc">&nbsp;                renderer.getBatch().draw(blankTexture, (camera.position.x - camera.viewportWidth/2), (camera.position.y - camera.viewportHeight/2), camera.viewportWidth, 20);</b>
&nbsp;                //renderer.getBatch().draw(blankTexture, (camera.position.x - camera.viewportWidth/2) + 3, (camera.position.y - camera.viewportHeight/2) + 3, 204, 44);
<b class="nc">&nbsp;                renderer.getBatch().setColor(Color.YELLOW);</b>
<b class="nc">&nbsp;                renderer.getBatch().draw(blankTexture, (camera.position.x - camera.viewportWidth/2), (camera.position.y - camera.viewportHeight/2), camera.viewportWidth * ((float) game.dayManager.getEnergy() /100), 20);</b>
&nbsp;                //renderer.getBatch().draw(blankTexture, (camera.position.x - camera.viewportWidth/2) + 5, (camera.position.y - camera.viewportHeight/2) + 5, 200 * ((float) DayManager.currentDay.getEnergy() /100), 40);
&nbsp;
<b class="nc">&nbsp;                renderer.getBatch().setColor(Color.WHITE);</b>
&nbsp;
&nbsp;                //Draw activity text
<b class="nc">&nbsp;                if(!activityManager.getText().isEmpty()){</b>
&nbsp;                    //logic for drawing bubble
<b class="nc">&nbsp;                    font.getData().setScale(1f);</b>
&nbsp;                    //Get text length
<b class="nc">&nbsp;                    GlyphLayout layout = new GlyphLayout();</b>
<b class="nc">&nbsp;                    layout.setText(font, activityManager.getText());</b>
<b class="nc">&nbsp;                    renderer.getBatch().draw(textBubble, activityManager.getTextPosition().x - 2, activityManager.getTextPosition().y, layout.width + 4, 50);</b>
<b class="nc">&nbsp;                    activityManager.drawTextBubble((SpriteBatch) renderer.getBatch(), font);</b>
<b class="nc">&nbsp;                    font.getData().setScale(2f);</b>
&nbsp;                    //changes timer
<b class="nc">&nbsp;                    bubbleTimer += Gdx.graphics.getDeltaTime();</b>
&nbsp;                    //removes bubble after timer ends
<b class="nc">&nbsp;                    float bubblePeriod = 3;</b>
<b class="nc">&nbsp;                    if(bubbleTimer &gt; bubblePeriod){</b>
<b class="nc">&nbsp;                        bubbleTimer -= bubblePeriod;</b>
<b class="nc">&nbsp;                        activityManager.setText(&quot;&quot;, 0, 0);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //Dims screen when energy lost
&nbsp;                // New: Modified to include the new game&#39;s dayManager attribute
<b class="nc">&nbsp;                if (state != GAME_OVER) {</b>
&nbsp;                    // alpha = 1 - time left%
&nbsp;                    // lower alpha makes game brighter
<b class="nc">&nbsp;                    currentAlpha = (game.dayManager.getTime()-8f) / 24;</b>
<b class="nc">&nbsp;                    currentAlpha = Float.min(currentAlpha, 0.6f);</b>
<b class="nc">&nbsp;                    dimTexture.setAlpha(currentAlpha);</b>
<b class="nc">&nbsp;                    dimTexture.draw(renderer.getBatch());</b>
&nbsp;                }
&nbsp;
&nbsp;
&nbsp;                //////////////////////////////////////////////////////////////////////////
&nbsp;                // The Counter and Counter Icons                                        //
&nbsp;                // Upper-left corner position for the counter box set and will not move //
<b class="nc">&nbsp;                float counterBoxX = camera.position.x - camera.viewportWidth / 2;</b>
<b class="nc">&nbsp;                float counterBoxY = (camera.position.y + camera.viewportHeight / 2) - counterBoxTexture.getHeight();</b>
&nbsp;                // drawing the counterbox texture
<b class="nc">&nbsp;                renderer.getBatch().draw(counterBoxTexture, counterBoxX, counterBoxY);</b>
&nbsp;
&nbsp;                // help space and structure the strings on top of the box
&nbsp;
<b class="nc">&nbsp;                float iconSize = 20;</b>
<b class="nc">&nbsp;                float iconSpacingX = 2;</b>
<b class="nc">&nbsp;                float iconSpacingY = 8;</b>
&nbsp;                // this is the verticalbar, that represents a day and increments to 7 during the game
<b class="nc">&nbsp;                float verticalBarStartX = counterBoxX + iconSpacingX + 24;</b>
<b class="nc">&nbsp;                float verticalBarStartY = counterBoxY + counterBoxTexture.getHeight() - iconSpacingY - iconSize - iconSpacingY + 13;</b>
&nbsp;
&nbsp;                // setting up the font size and colour
<b class="nc">&nbsp;                font.getData().setScale(1f);</b>
<b class="nc">&nbsp;                font.setColor(Color.BLACK);</b>
&nbsp;
&nbsp;                // Defining the Y position for each row
<b class="nc">&nbsp;                float firstRowY = counterBoxY + counterBoxTexture.getHeight() - iconSpacingY - iconSize - 20;</b>
<b class="nc">&nbsp;                float secondRowY = firstRowY - iconSize - iconSpacingY;</b>
<b class="nc">&nbsp;                float thirdRowY = secondRowY - iconSize - iconSpacingY;</b>
&nbsp;
&nbsp;                // draw the player&#39;s score for the three activity type
&nbsp;                // New: Modified lines to include the game&#39;s dayManager attribute
<b class="nc">&nbsp;                font.draw(renderer.getBatch(), String.valueOf(game.dayManager.overallEatCount), counterBoxX + 43, firstRowY+18);</b>
<b class="nc">&nbsp;                font.draw(renderer.getBatch(), String.valueOf(game.dayManager.overallStudyCount), counterBoxX + 43, secondRowY+27);</b>
<b class="nc">&nbsp;                font.draw(renderer.getBatch(), String.valueOf(game.dayManager.overallRecreationalCount), counterBoxX + 43, thirdRowY+36);</b>
&nbsp;
&nbsp;                // Draw the Day icon in the first row
<b class="nc">&nbsp;                for (int i = 0; i &lt; game.dayManager.getDayNumber(); i++) {</b>
<b class="nc">&nbsp;                    renderer.getBatch().draw(verticalBarSprite, verticalBarStartX+15 + (5 + iconSpacingX) * i, verticalBarStartY, 5, 20);</b>
&nbsp;                }
&nbsp;
&nbsp;                // New: Display the current time
<b class="nc">&nbsp;                float timeX = camera.position.x - 10;</b>
<b class="nc">&nbsp;                float timeY = camera.position.y - (camera.viewportHeight / 2) + 16;</b>
<b class="nc">&nbsp;                font.setColor(Color.RED);</b>
<b class="nc">&nbsp;                int time = (int) game.dayManager.getTime();</b>
<b class="nc">&nbsp;                if(time == 24){</b>
<b class="nc">&nbsp;                    font.draw(renderer.getBatch(),&quot;00:00&quot;, timeX, timeY);</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    font.draw(renderer.getBatch(), time + &quot;:00&quot;, timeX, timeY);</b>
&nbsp;                }
&nbsp;                //else { font.draw(renderer.getBatch(), time - 11 +&quot; pm&quot;, timeX, timeY); }
&nbsp;
&nbsp;                //End of main renderer
<b class="nc">&nbsp;                renderer.getBatch().end();</b>
&nbsp;                //Draw sound buttons. (currently can&#39;t have buttons get input while other menus have input)
<b class="nc">&nbsp;                stage.act(Gdx.graphics.getDeltaTime());</b>
<b class="nc">&nbsp;                stage.draw();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case (GAME_PAUSED):
&nbsp;                //Dims screen when energy lost
&nbsp;                // New: modified to use the game&#39;s dayManager
<b class="nc">&nbsp;                dimTexture.setAlpha(currentAlpha);</b>
<b class="nc">&nbsp;                dimTexture.draw(renderer.getBatch());</b>
&nbsp;   
&nbsp;                //Pause menu
<b class="nc">&nbsp;                renderer.getBatch().end();</b>
<b class="nc">&nbsp;                pauseMenu.update(camera);</b>
<b class="nc">&nbsp;                pauseMenu.draw();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case (GAME_SETTINGS):
&nbsp;                //Dims screen when energy lost
&nbsp;                // New: modified to include game&#39;s dayManager
<b class="nc">&nbsp;                dimTexture.setAlpha(currentAlpha);</b>
<b class="nc">&nbsp;                dimTexture.draw(renderer.getBatch());</b>
&nbsp;
&nbsp;                //Settings menu
<b class="nc">&nbsp;                renderer.getBatch().end();</b>
<b class="nc">&nbsp;                settingsMenu.update();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case (GAME_OVER):
&nbsp;                // Fade to 100% alpha
<b class="nc">&nbsp;                currentAlpha += 1f * delta * 0.6f;</b>
<b class="nc">&nbsp;                currentAlpha = Float.min(currentAlpha, 1);</b>
<b class="nc">&nbsp;                dimTexture.setAlpha(currentAlpha);</b>
<b class="nc">&nbsp;                dimTexture.draw(renderer.getBatch());</b>
<b class="nc">&nbsp;                renderer.getBatch().end();</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Update the game every frame, checking/handling player movement
&nbsp;     */
&nbsp;    private void update(){
&nbsp;        //Detect if game should be paused or not
<b class="nc">&nbsp;        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)||Gdx.input.isKeyJustPressed(Input.Keys.P)){</b>
<b class="nc">&nbsp;            if (state!=GAME_PAUSED) {</b>
<b class="nc">&nbsp;                state = GAME_PAUSED;</b>
&nbsp;            }
&nbsp;            else{
<b class="nc">&nbsp;                state = GAME_RUNNING;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        //logic/physics - anything that moves
<b class="nc">&nbsp;        switch (state){</b>
&nbsp;            case (GAME_RUNNING):
<b class="nc">&nbsp;                Gdx.input.setInputProcessor(inputMultiplexer);</b>
<b class="nc">&nbsp;                player.update(Gdx.graphics.getDeltaTime());</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case (GAME_SETTINGS)://we do the same settings or paused
&nbsp;            // New: Modified to include the game leaderboard
&nbsp;            case (GAME_PLAYER_SELECT):
&nbsp;            case (GAME_LEADERBOARD):
&nbsp;            case (GAME_PAUSED):
<b class="nc">&nbsp;                player.update(0);</b>
<b class="nc">&nbsp;                player.setVelocity(new Vector2(0,0));</b>
<b class="nc">&nbsp;                pauseMenu.update(camera);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            // New: add end game logic
&nbsp;            case (GAME_OVER):
<b class="nc">&nbsp;                if (currentAlpha == 1) {</b>
<b class="nc">&nbsp;                    game.setScreen(new GameOverScreen(game));</b>
&nbsp;                }
&nbsp;                break;
&nbsp;        }
&nbsp;
&nbsp;        // check walking is happening, by first checking if the player has a velocity 0
<b class="nc">&nbsp;        if (Math.abs(player.getVelocity().x) &gt; 0 || Math.abs(player.getVelocity().y) &gt; 0) {</b>
<b class="nc">&nbsp;            if (!isWalking) {</b>
<b class="nc">&nbsp;                isWalking = true;</b>
<b class="nc">&nbsp;                currentWalkingSoundIndex = 0;</b>
<b class="nc">&nbsp;                walkingSoundTimer = WALKING_SOUND_DELAY;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            isWalking = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        playWalkingSound(Gdx.graphics.getDeltaTime());</b>
<b class="nc">&nbsp;        stage.act(Gdx.graphics.getDeltaTime());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Show is called the first time this object is drawn
&nbsp;     * Used here to set up variables like sprites and textures, and assign references
&nbsp;     * to the camera, renderer, collision layer, and our manager classes.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void show() {
&nbsp;
&nbsp;        // Initialize the camera
<b class="nc">&nbsp;        camera = new OrthographicCamera();</b>
<b class="nc">&nbsp;        camera.setToOrtho(false, 800, 450);</b>
<b class="nc">&nbsp;        extendViewport = new ExtendViewport(camera.viewportWidth, camera.viewportHeight, camera);</b>
&nbsp;        // Load the map and set up the renderer
&nbsp;
<b class="nc">&nbsp;        map = new TmxMapLoader().load(MAP);</b>
<b class="nc">&nbsp;        TiledMapTileLayer collisionLayer = (TiledMapTileLayer) map.getLayers().get(1);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        renderer = new OrthogonalTiledMapRenderer(map, 1);</b>
&nbsp;
&nbsp;        // Set up the player
<b class="nc">&nbsp;        Sprite playerSprite = new Sprite(playerTexture);</b>
<b class="nc">&nbsp;        player = new Player(playerSprite, collisionLayer);</b>
<b class="nc">&nbsp;        float startX = 50 * collisionLayer.getTileWidth();</b>
<b class="nc">&nbsp;        float startY = (collisionLayer.getHeight() - 26) * collisionLayer.getTileHeight();</b>
<b class="nc">&nbsp;        player.setPosition(startX, startY);</b>
&nbsp;
&nbsp;        // Set up the activity manager
&nbsp;        // New: added the new activity manager for a more intuitive management of the activities the player can do
<b class="nc">&nbsp;        activityManager = new ActivityManager(map.getLayers().get(&quot;Activities&quot;), game.dayManager);</b>
&nbsp;
&nbsp;        // Set up the font
<b class="nc">&nbsp;        font = new BitmapFont();</b>
<b class="nc">&nbsp;        font.getData().setScale(2);</b>
&nbsp;
&nbsp;        // Set up blank texture (used for energy bar)
<b class="nc">&nbsp;        TblankTexture = new Texture(WHITE_SQUARE);</b>
<b class="nc">&nbsp;        blankTexture = new Sprite(TblankTexture);</b>
&nbsp;
&nbsp;        // Set up text bubble
<b class="nc">&nbsp;        textBubbleTexture = new Texture(TEXT_BUBBLE);</b>
<b class="nc">&nbsp;        textBubble = new Sprite(textBubbleTexture);</b>
&nbsp;
&nbsp;        //setup menu
<b class="nc">&nbsp;        pauseMenu = new PauseMenu(extendViewport, camera);</b>
<b class="nc">&nbsp;        settingsMenu = new SettingsMenu(GAME_PAUSED,camera,extendViewport,2);</b>
&nbsp;
&nbsp;        //set state
<b class="nc">&nbsp;        state = GAME_RUNNING;</b>
&nbsp;        // Set up the counter and counter components
<b class="nc">&nbsp;        counterBoxTexture = new Texture(COUNTER_BOX);</b>
&nbsp;
&nbsp;        // set up for the vertical bar that counts the days
<b class="nc">&nbsp;        verticalBarTexture = new Texture(VERTICAL_BAR);</b>
<b class="nc">&nbsp;        verticalBarSprite = new Sprite(verticalBarTexture);</b>
&nbsp;        // set up and connect the audio for the steps of the player
<b class="nc">&nbsp;        walkingSound1 = Gdx.audio.newSound(Gdx.files.internal(TILE_1));</b>
<b class="nc">&nbsp;        walkingSound2 = Gdx.audio.newSound(Gdx.files.internal(TILE_2));</b>
<b class="nc">&nbsp;        walkingSound3 = Gdx.audio.newSound(Gdx.files.internal(TILE_3));</b>
<b class="nc">&nbsp;        walkingSound4 = Gdx.audio.newSound(Gdx.files.internal(TILE_4));</b>
&nbsp;        // set up and connect the audio for the background music to always loop
<b class="nc">&nbsp;        backgroundMusic = Gdx.audio.newMusic(Gdx.files.internal(&quot;Sounds/background-music.mp3&quot;));</b>
<b class="nc">&nbsp;        backgroundMusic.setLooping(true);</b>
<b class="nc">&nbsp;        backgroundMusic.setVolume(volume);</b>
<b class="nc">&nbsp;        backgroundMusic.play();</b>
&nbsp;
<b class="nc">&nbsp;        dimTexture = new Sprite(blankTexture);</b>
<b class="nc">&nbsp;        dimTexture.setColor(Color.BLACK);</b>
<b class="nc">&nbsp;        dimTexture.setSize(collisionLayer.getWidth() * 16, collisionLayer.getHeight() * 16);</b>
&nbsp;        // set up the click sound for the buttons ui
<b class="nc">&nbsp;        clickSound = Gdx.audio.newSound(Gdx.files.internal(CLICK));</b>
&nbsp;
&nbsp;
&nbsp;        // Create the stage for the UI elements
<b class="nc">&nbsp;        stage = new Stage(extendViewport, renderer.getBatch());</b>
&nbsp;
&nbsp;        // a Multiplexer is needed in the play screen to be able to manage inputs from the UI and the player
<b class="nc">&nbsp;        inputMultiplexer = new InputMultiplexer();</b>
&nbsp;        // Stage first to ensure UI input is prioritized
<b class="nc">&nbsp;        inputMultiplexer.addProcessor(stage);</b>
&nbsp;        // Then player
<b class="nc">&nbsp;        inputMultiplexer.addProcessor(player);</b>
&nbsp;        // Set the global input processor to receive input from touch keys to the input multiplexer
&nbsp;
<b class="nc">&nbsp;        Gdx.input.setInputProcessor(inputMultiplexer);</b>
&nbsp;
&nbsp;
&nbsp;        // Prepare textures for buttons
<b class="nc">&nbsp;        increaseVolumeTexture = new Texture(Gdx.files.internal(VOLUME_UP));</b>
<b class="nc">&nbsp;        lowerVolumeTexture = new Texture(Gdx.files.internal(VOLUME_DOWN));</b>
<b class="nc">&nbsp;        volumeOffTexture = new Texture(Gdx.files.internal(VOLUME_OFF));</b>
<b class="nc">&nbsp;        volumeOnTexture = new Texture(Gdx.files.internal(VOLUME_ON));</b>
&nbsp;
&nbsp;
&nbsp;
&nbsp;        // Create and set up the 4 volume buttons
&nbsp;        // increases the volume of the game if not already to the max
&nbsp;
<b class="nc">&nbsp;        Button.ButtonStyle increaseVolumeStyle = new Button.ButtonStyle();</b>
<b class="nc">&nbsp;        increaseVolumeStyle.up = new TextureRegionDrawable(new TextureRegion(increaseVolumeTexture));</b>
<b class="nc">&nbsp;        increaseVolumeButton = new Button(increaseVolumeStyle);</b>
&nbsp;
<b class="nc">&nbsp;        increaseVolumeButton.addListener(new ClickListener() {</b>
&nbsp;            @Override
&nbsp;            public void clicked(InputEvent event, float x, float y) {
<b class="nc">&nbsp;                clickSound.play();</b>
<b class="nc">&nbsp;                volume = Math.min(volume + 0.1f, 1.0f);</b>
<b class="nc">&nbsp;                backgroundMusic.setVolume(volume);</b>
&nbsp;            }
&nbsp;        });
&nbsp;
&nbsp;        // lowers the volume, checks the volume and subtracts from it
<b class="nc">&nbsp;        Button.ButtonStyle lowerVolumeStyle = new Button.ButtonStyle();</b>
<b class="nc">&nbsp;        lowerVolumeStyle.up = new TextureRegionDrawable(new TextureRegion(lowerVolumeTexture));</b>
<b class="nc">&nbsp;        lowerVolumeButton = new Button(lowerVolumeStyle);</b>
<b class="nc">&nbsp;        lowerVolumeButton.addListener(new ClickListener() {</b>
&nbsp;            @Override
&nbsp;            public void clicked(InputEvent event, float x, float y) {
<b class="nc">&nbsp;                clickSound.play();</b>
<b class="nc">&nbsp;                volume = Math.max(volume - 0.1f, 0.0f);</b>
<b class="nc">&nbsp;                backgroundMusic.setVolume(volume);</b>
&nbsp;            }
&nbsp;        });
&nbsp;        // turns off the volume
<b class="nc">&nbsp;        Button.ButtonStyle volumeOffStyle = new Button.ButtonStyle();</b>
<b class="nc">&nbsp;        volumeOffStyle.up = new TextureRegionDrawable(new TextureRegion(volumeOffTexture));</b>
<b class="nc">&nbsp;        volumeOffButton = new Button(volumeOffStyle);</b>
<b class="nc">&nbsp;        volumeOffButton.addListener(new ClickListener() {</b>
&nbsp;            @Override
&nbsp;            public void clicked(InputEvent event, float x, float y) {
<b class="nc">&nbsp;                clickSound.play();</b>
<b class="nc">&nbsp;                if (backgroundMusic.isPlaying()) {</b>
<b class="nc">&nbsp;                    backgroundMusic.pause();</b>
&nbsp;
<b class="nc">&nbsp;                    volume = 0;</b>
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;
&nbsp;        // Play the music if it is not already playing
<b class="nc">&nbsp;        Button.ButtonStyle volumeOnStyle = new Button.ButtonStyle();</b>
<b class="nc">&nbsp;        volumeOnStyle.up = new TextureRegionDrawable(new TextureRegion(volumeOnTexture));</b>
<b class="nc">&nbsp;        volumeOnButton = new Button(volumeOnStyle);</b>
<b class="nc">&nbsp;        volumeOnButton.addListener(new ClickListener() {</b>
&nbsp;            @Override
&nbsp;            public void clicked(InputEvent event, float x, float y) {
<b class="nc">&nbsp;                clickSound.play();</b>
<b class="nc">&nbsp;                if (!backgroundMusic.isPlaying()) {</b>
<b class="nc">&nbsp;                    backgroundMusic.play();</b>
<b class="nc">&nbsp;                    volume = 1.0f;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;        // makes the buttons interactive
<b class="nc">&nbsp;        stage.addActor(increaseVolumeButton);</b>
<b class="nc">&nbsp;        stage.addActor(lowerVolumeButton);</b>
<b class="nc">&nbsp;        stage.addActor(volumeOffButton);</b>
<b class="nc">&nbsp;        stage.addActor(volumeOnButton);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;    @Override
&nbsp;    public void hide() {
<b class="nc">&nbsp;        dispose();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets width and height screen resized to and updates viewport
&nbsp;     * @param width width changed to
&nbsp;     * @param height height changed to
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void resize(int width, int height) {
<b class="nc">&nbsp;        extendViewport.update(width,height);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void pause() {
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void resume() {
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;    /**
&nbsp;     * Called when this screen should release all resources.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void dispose() {
<b class="nc">&nbsp;        map.dispose();</b>
<b class="nc">&nbsp;        player.getTexture().dispose();</b>
<b class="nc">&nbsp;        font.dispose();</b>
<b class="nc">&nbsp;        counterBoxTexture.dispose();</b>
<b class="nc">&nbsp;        verticalBarTexture.dispose();</b>
<b class="nc">&nbsp;        walkingSound1.dispose();</b>
<b class="nc">&nbsp;        walkingSound2.dispose();</b>
<b class="nc">&nbsp;        walkingSound3.dispose();</b>
<b class="nc">&nbsp;        walkingSound4.dispose();</b>
<b class="nc">&nbsp;        settingsMenu.dispose();</b>
<b class="nc">&nbsp;        pauseMenu.dispose();</b>
<b class="nc">&nbsp;        if (backgroundMusic != null) {</b>
<b class="nc">&nbsp;            backgroundMusic.dispose();</b>
&nbsp;        }
<b class="nc">&nbsp;        stage.dispose();</b>
<b class="nc">&nbsp;        increaseVolumeTexture.dispose();</b>
<b class="nc">&nbsp;        lowerVolumeTexture.dispose();</b>
<b class="nc">&nbsp;        volumeOffTexture.dispose();</b>
<b class="nc">&nbsp;        volumeOnTexture.dispose();</b>
<b class="nc">&nbsp;        TblankTexture.dispose();</b>
<b class="nc">&nbsp;        textBubbleTexture.dispose();</b>
<b class="nc">&nbsp;        backgroundMusic.dispose();</b>
<b class="nc">&nbsp;        increaseVolumeTexture.dispose();</b>
<b class="nc">&nbsp;        volumeOffTexture.dispose();</b>
<b class="nc">&nbsp;        volumeOnTexture.dispose();</b>
<b class="nc">&nbsp;        lowerVolumeTexture.dispose();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // checks when to play the walking sound
&nbsp;    private void playWalkingSound(float delta) {
<b class="nc">&nbsp;        if (!isWalking || walkingSoundTimer &lt; WALKING_SOUND_DELAY) {</b>
<b class="nc">&nbsp;            walkingSoundTimer += delta;</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        // when the player is moving alternates between different walking sounds
<b class="nc">&nbsp;        walkingSoundTimer = 0;</b>
&nbsp;
<b class="nc">&nbsp;        Sound soundToPlay = null;</b>
<b class="nc">&nbsp;        switch (currentWalkingSoundIndex) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                soundToPlay = walkingSound1;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 1:
<b class="nc">&nbsp;                soundToPlay = walkingSound2;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 2:
<b class="nc">&nbsp;                soundToPlay = walkingSound3;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                soundToPlay = walkingSound4;</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        if (soundToPlay != null) {</b>
<b class="nc">&nbsp;            soundToPlay.play(volume);</b>
<b class="nc">&nbsp;            currentWalkingSoundIndex = (currentWalkingSoundIndex + 1) % 4;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     *If camera showed out of map, move it in
&nbsp;     * @param cam camera to keep position within layer
&nbsp;     * @param layer TiledMapTile layer to lock
&nbsp;     */
&nbsp;    private void lockCameraInTiledMapLayer(OrthographicCamera cam, TiledMapTileLayer layer){
&nbsp;        //get variables needed to find edges of map!
<b class="nc">&nbsp;        int mapPixelOffsetY =(int) layer.getOffsetY();</b>
<b class="nc">&nbsp;        int mapPixelOffsetX =(int) layer.getOffsetX();</b>
<b class="nc">&nbsp;        int mapPixelWidth = layer.getWidth() * layer.getTileWidth() + mapPixelOffsetX;</b>
<b class="nc">&nbsp;        int mapPixelHeight = layer.getHeight() * layer.getTileHeight() + mapPixelOffsetY;</b>
&nbsp;        //if the camera viewport is large enough to see outside the map on both sides at once, there is no useful way to lock it. this shouldn&#39;t happen
<b class="nc">&nbsp;        if (cam.viewportWidth&gt;mapPixelWidth || cam.viewportHeight&gt;mapPixelHeight){</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;
&nbsp;        //check if camera would show out of bounds, lock it in bounds if it would
<b class="nc">&nbsp;        if ((cam.position.x- (cam.viewportWidth/2)&lt; mapPixelOffsetX))//is the camera too far left.</b>
&nbsp;        {
<b class="nc">&nbsp;            cam.position.x = mapPixelOffsetX + cam.viewportWidth/2;</b>
&nbsp;        }
<b class="nc">&nbsp;        else if ((cam.position.x+ (cam.viewportWidth/2)&gt; mapPixelWidth))//is the camera too far right.</b>
&nbsp;        {
<b class="nc">&nbsp;            cam.position.x = mapPixelWidth - cam.viewportWidth/2;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((cam.position.y- (cam.viewportHeight/2)&lt; mapPixelOffsetY))//is the camera too low.</b>
&nbsp;        {
<b class="nc">&nbsp;            cam.position.y = mapPixelOffsetY + cam.viewportHeight/2;</b>
&nbsp;        }
<b class="nc">&nbsp;        else if ((cam.position.y+ (cam.viewportHeight/2)&gt; mapPixelHeight))//is the camera too high.</b>
&nbsp;        {
<b class="nc">&nbsp;            cam.position.y = mapPixelHeight - cam.viewportHeight/2;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Get font in another class
&nbsp;     * @return games value of font
&nbsp;     */
&nbsp;    public static BitmapFont getFont(){
<b class="fc">&nbsp;        if (font == null){</b>
<b class="fc">&nbsp;            font = new BitmapFont();</b>
<b class="fc">&nbsp;            font.getData().setScale(2);</b>
&nbsp;        }
<b class="fc">&nbsp;        return font;</b>
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-05-20 17:40</div>
</div>
</body>
</html>
